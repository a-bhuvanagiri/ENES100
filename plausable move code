#include "Arduino.h"
#include "Enes100.h"

// ====== CONFIGURATION ======

// Motor pins
const int leftDirPin = 4;
const int leftPWMPin = 5;
const int rightDirPin = 7;
const int rightPWMPin = 6;

// Ultrasonic sensor pins (only used if USE_REAL_SENSOR is true)
const int trigPin = 10;
const int echoPin = 11;

// Toggle between using a real front sensor or virtual map-based avoidance
const bool USE_REAL_SENSOR = false;

// Define obstacles for virtual mode
struct Obstacle {
  float x;
  float y;
  float radius;
};

Obstacle obstacles[] = {
  {1.5, 1.0, 0.25},
  {2.3, 1.8, 0.25},
  {3.0, 0.9, 0.25}
};

const int numObstacles = sizeof(obstacles) / sizeof(Obstacle);

// ====== MOTOR CONTROL ======

void setLeftMotorPWM(int pwm) {
  digitalWrite(leftDirPin, pwm >= 0 ? HIGH : LOW);
  analogWrite(leftPWMPin, abs(pwm));
}

void setRightMotorPWM(int pwm) {
  digitalWrite(rightDirPin, pwm >= 0 ? HIGH : LOW);
  analogWrite(rightPWMPin, abs(pwm));
}

void stopMotors() {
  analogWrite(leftPWMPin, 0);
  analogWrite(rightPWMPin, 0);
}

// ====== ULTRASONIC SENSOR (REAL) ======

long getDistanceCM() {
  digitalWrite(trigPin, LOW);
  delayMicroseconds(2);
  digitalWrite(trigPin, HIGH);
  delayMicroseconds(10);
  digitalWrite(trigPin, LOW);
  long duration = pulseIn(echoPin, HIGH);
  return duration * 0.034 / 2; // Convert to cm
}

// ====== VIRTUAL OBSTACLE CHECKING ======

bool isNearVirtualObstacle(float x, float y) {
  for (int i = 0; i < numObstacles; i++) {
    float dx = x - obstacles[i].x;
    float dy = y - obstacles[i].y;
    if (sqrt(dx * dx + dy * dy) < obstacles[i].radius) {
      return true;
    }
  }
  return false;
}

// ====== SMART AVOIDANCE ======

void smartAvoid(float x, float y, float theta) {
  // Back up
  setLeftMotorPWM(-100);
  setRightMotorPWM(-100);
  delay(400);
  stopMotors();
  delay(200);

  // Random turn direction (left or right)
  if (random(0, 2) == 0) {
    // Turn right
    setLeftMotorPWM(100);
    setRightMotorPWM(-100);
  } else {
    // Turn left
    setLeftMotorPWM(-100);
    setRightMotorPWM(100);
  }
  delay(400);
  stopMotors();
  delay(200);
}

// ====== SETUP ======

void setup() {
  pinMode(leftDirPin, OUTPUT);
  pinMode(leftPWMPin, OUTPUT);
  pinMode(rightDirPin, OUTPUT);
  pinMode(rightPWMPin, OUTPUT);

  if (USE_REAL_SENSOR) {
    pinMode(trigPin, OUTPUT);
    pinMode(echoPin, INPUT);
  }

  Enes100.begin("Simulator", DATA, 3, 1116, 8, 9);
  Enes100.println("Initialized and ready!");
  randomSeed(analogRead(0)); // For random turn direction
}

// ====== LOOP ======

void loop() {
  float x = Enes100.getX();
  float y = Enes100.getY();
  float theta = Enes100.getTheta();

  bool obstacleDetected = false;

  if (USE_REAL_SENSOR) {
    long distance = getDistanceCM();
    Enes100.print("Ultrasonic distance (cm): ");
    Enes100.println(distance);
    obstacleDetected = distance < 20; // Obstacle within 20 cm
  } else {
    obstacleDetected = isNearVirtualObstacle(x, y);
  }

  if (obstacleDetected) {
    Enes100.println("Obstacle detected! Avoiding...");
    smartAvoid(x, y, theta);
  } else {
    setLeftMotorPWM(150);
    setRightMotorPWM(150);
  }

  delay(100);
}
